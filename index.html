<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Right-Click Meme Generator by Frosty</title>
  <style>
    /* NOTE: keep this file next to index.html named EXACTLY: Windows Regular.ttf */
    @font-face{font-family:'WindowsRegular';src:url('Windows Regular.ttf') format('truetype');font-display:swap}

    :root{
      --win95-face:#c0c0c0; --win95-light:#ffffff; --win95-mid:#dfdfdf; --win95-shadow:#808080; --win95-dark:#000000;
      --win95-blue:#000080; --win95-blue-light:#1084d0; --text:#000; --link:#0000ee;
      --warn:#b00020;
    }
    *{box-sizing:border-box}
    body{margin:0;background:#008080;color:var(--text);font:14px/1.3 'WindowsRegular','MS Sans Serif',Tahoma,Arial,sans-serif;}

    .win95-window{
      width:min(1200px,95vw); margin:16px auto; background:var(--win95-face);
      border:2px solid var(--win95-dark); border-right-color:var(--win95-light); border-bottom-color:var(--win95-light);
      box-shadow: inset -1px -1px 0 var(--win95-dark), inset 1px 1px 0 var(--win95-light),
                  inset -2px -2px 0 var(--win95-shadow), inset 2px 2px 0 var(--win95-mid);
    }
    .win95-titlebar{
      height:28px; display:flex; align-items:center; justify-content:space-between; padding:0 6px;
      background:linear-gradient(180deg,var(--win95-blue-light),var(--win95-blue)); color:#fff; font-weight:bold; user-select:none;
    }
    .win95-titlebar .title{display:flex; gap:8px; align-items:center;}
    .win95-titlebar .controls{display:flex; gap:4px;}
    .win95-button-title{width:18px;height:18px;display:grid;place-items:center;background:var(--win95-face);color:#000;
      border:2px solid var(--win95-dark);border-right-color:var(--win95-light);border-bottom-color:var(--win95-light);font-size:12px;}

    .win95-menubar{
      display:flex; gap:12px; padding:6px; font-size:12px; background:var(--win95-face);
      border-top:1px solid var(--win95-light); border-left:1px solid var(--win95-light);
      border-right:1px solid var(--win95-dark); border-bottom:1px solid var(--win95-dark);
    }

    .wrap{display:grid; grid-template-columns:320px 1fr; min-height:70vh;}
    aside{padding:10px; background:var(--win95-face); border-right:2px solid var(--win95-dark); border-left:2px solid var(--win95-light);}
    .group{
      margin:0 0 10px; padding:10px; background:var(--win95-face);
      border:2px solid var(--win95-dark); border-right-color:var(--win95-light); border-bottom-color:var(--win95-light);
      box-shadow: inset -1px -1px 0 var(--win95-dark), inset 1px 1px 0 var(--win95-light);
    }
    .group h3{margin:-4px 0 8px; padding:0 4px; font-size:12px; font-weight:normal; display:inline-block; background:var(--win95-face);}
    label{display:block; font-size:12px; margin:6px 0 2px;}
    .row{display:flex; gap:8px;} .row>*{flex:1;}

    input[type="text"],input[type="number"],input[type="color"],select,input[type="range"]{
      width:100%; padding:4px 6px; background:#fff; color:#000;
      border:2px solid var(--win95-dark); border-right-color:var(--win95-light); border-bottom-color:var(--win95-light);
      font:13px 'WindowsRegular','MS Sans Serif',Tahoma,Arial,sans-serif; outline:none;
    }
    button{
      appearance:none; cursor:default; padding:4px 10px; background:var(--win95-face); color:#000;
      border:2px solid var(--win95-dark); border-right-color:var(--win95-light); border-bottom-color:var(--win95-light);
      font:13px 'WindowsRegular','MS Sans Serif',Tahoma,Arial,sans-serif;
    }
    button:active{border-left-color:var(--win95-light); border-top-color:var(--win95-light);}
    .primary{font-weight:bold;}

    main{display:grid; place-items:center; padding:10px; background:var(--win95-face);}
    canvas{
      background:#000; max-width:100%; height:auto;
      border:2px solid var(--win95-dark); border-right-color:var(--win95-light); border-bottom-color:var(--win95-light);
      image-rendering:pixelated;
    }
    a{color:var(--link); text-decoration:underline;}
    .statusbar{
      padding:4px 6px; font-size:12px; display:flex; justify-content:space-between; gap:12px; background:var(--win95-face);
      border-top:2px solid var(--win95-light); border-left:2px solid var(--win95-light);
      border-right:2px solid var(--win95-dark); border-bottom:2px solid var(--win95-dark);
    }
    #status{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:60ch;}
    #warn{display:none;color:#fff;background:var(--warn);padding:6px 10px;font-size:12px}
    #warn.show{display:block;}
  </style>
</head>
<body>
  <div class="win95-window">
    <div class="win95-titlebar">
      <div class="title"><span style="filter:drop-shadow(1px 1px 0 #000);">▣</span><span>Frosty's Right-Click Meme Generator</span></div>
      <div class="controls"><div class="win95-button-title">–</div><div class="win95-button-title">▢</div><div class="win95-button-title">×</div></div>
    </div>

    <div id="warn"></div>

    <div class="win95-menubar">
      <div><u>F</u>ile</div><div><u>E</u>dit</div><div><u>V</u>iew</div><div><u>H</u>elp</div>
      <div style="margin-left:auto;"><button id="btn-save" class="primary">Save Meme</button></div>
    </div>

    <div class="wrap">
      <aside>
        <div class="group">
          <h3>Canvas</h3>
          <div class="row">
            <div><label>Width (px)</label><input type="number" id="w" value="1500" min="64"></div>
            <div><label>Height (px)</label><input type="number" id="h" value="500" min="64"></div>
          </div>
          <div class="row">
            <div><label>Background</label><input type="color" id="bg" value="#cfc6a7"></div>
          </div>
        </div>

        <div class="group">
          <h3>Quick Fill</h3>
          <div class="row">
            <button id="btnUploadUserPic">Upload Picture</button>
            <button id="btnReplacePic">Replace Picture</button>
          </div>
          <div class="row" style="margin-top:6px;">
            <button id="btnDeletePic">✕ Delete Picture</button>
          </div>
          <label>Text under picture</label><input type="text" id="txtBelow" placeholder="type text 1">
          <label>Text in highlighted field</label><input type="text" id="txtMenu" placeholder="type text 2">
          <div style="font-size:12px;margin-top:6px">Tip: Click an item on the canvas to select. Drag to move. Use corner squares to resize.</div>
        </div>

        <!-- Background Options (compact, above Connect) -->
        <div class="group">
          <h3>Background Options</h3>
          <label>Preset (optional)</label>
          <select id="bgSelect">
  <option value="">Use color only</option>

  <!-- existing presets -->
  <option value="WindowsBG.png">WindowsBG.png</option>
  <option value="TrailerTrashBG.png">TrailerTrashBG.png</option>
  <option value="Retro1BG.png">Retro1BG.png</option>
  <option value="Retro2BG.png">Retro2BG.png</option>
  <option value="FireBG.png">FireBG.png</option>

  <!-- new presets -->
  <option value="NotStonksBG.png">NotStonksBG.png</option>
  <option value="StonkBG.png">StonkBG.png</option>
  <option value="RainbowWheel.png">RainbowWheel.png</option>
  <option value="TrollBG.png">TrollBG.png</option>
  <option value="UnstableCoinBG.png">UnstableCoinBG.png</option>
  <option value="UnstableCoin2BG.png">UnstableCoin2BG.png</option>          

  <!-- upload option (keeps your custom-upload flow) -->
  <option value="__upload__">Upload custom…</option>
</select>
          <input type="file" id="bgUpload" accept="image/*" style="display:none">
          <p style="margin:6px 0 0; font-size:12px; opacity:.85;">
            Tip: backgrounds are optimized for <strong>1500 × 500</strong> px.
          </p>
          <label style="margin-top:6px;">Preset opacity: <span id="bgOpacityValue">100%</span></label>
          <input type="range" id="bgOpacity" min="0" max="1" step="0.01" value="1">
        </div>

        <div class="group">
          <h3>Connect</h3>
          <p style="font-size:13px;margin:0;">Follow me on <a href="https://x.com/iclickmeme" target="_blank">X @iclickmeme</a></p>
        </div>
      </aside>

      <main><canvas id="cv" width="1500" height="500"></canvas></main>
    </div>

    <div class="statusbar"><div id="status">Ready</div><div>© Frosty</div></div>
  </div>

  <script>
  const $ = (s)=>document.querySelector(s);
  const cv = $('#cv'), ctx = cv.getContext('2d');
  const warn = $('#warn');

  // State (includes bg preset alpha)
  const state = { w:1500, h:500, bg:'#cfc6a7', bgPreset:{src:null,img:null,alpha:1}, layers:[], selected:null };
  const HANDLE = 10;
  const uid = ()=>Math.random().toString(36).slice(2,9);

  // ===== Forgiving filename resolver for universal assets =====
  const CANDIDATES = (base)=>[
    `${base}.png`, `${base}.PNG`, `${base}.jpg`, `${base}.jpeg`,
    `assets/${base}.png`, `assets/${base}.PNG`, `assets/${base}.jpg`, `assets/${base}.jpeg`,
    `${base.toLowerCase()}.png`, `${base.toLowerCase()}.PNG`, `${base.toLowerCase()}.jpg`,
    `assets/${base.toLowerCase()}.png`, `assets/${base.toLowerCase()}.PNG`, `assets/${base.toLowerCase()}.jpg`
  ];

  // For your five locked layers
  const UNIVERSALS = {
    Menu: CANDIDATES('Menu'),
    ImageSelectLines: CANDIDATES('ImageSelectLines'),
    launchIcon: CANDIDATES('launchIcon'),
    MouseCursor: CANDIDATES('MouseCursor'),
    ScreenTexture: CANDIDATES('ScreenTexture')
  };

  // Try to load the first variant that exists
  async function loadFirst(names){
    for(const src of names){
      const im = await loadImg(src, /*quiet*/true);
      if(im) return {img:im, src};
    }
    return null;
  }

  function textMetrics(layer){ const t = layer.data; ctx.save(); ctx.font = `${t.size}px ${t.font}`; const w = ctx.measureText(t.text||' ').width; ctx.restore(); const h = t.size*1.2; return {w,h}; }
  function getBounds(layer){
    if(layer.type==='image' && layer.data.img){
      const w = layer.data.img.naturalWidth * layer.scale;
      const h = layer.data.img.naturalHeight * layer.scale;
      return {x:layer.x - w/2, y:layer.y - h/2, w, h};
    }
    if(layer.type==='text'){
      const m = textMetrics(layer); const w=m.w*layer.scale, h=m.h*layer.scale;
      let x0=layer.x; if(layer.data.align==='center') x0-=w/2; if(layer.data.align==='right') x0-=w;
      const y0=layer.y-h/2; return {x:x0,y:y0,w,h};
    }
    return {x:layer.x-20,y:layer.y-20,w:40,h:40};
  }
  function drawHandles(b){
    ctx.save(); ctx.strokeStyle='#00ffff'; ctx.lineWidth=1; ctx.setLineDash([6,3]);
    ctx.strokeRect(b.x,b.y,b.w,b.h); ctx.setLineDash([]); ctx.fillStyle='#00ffff';
    ctx.fillRect(b.x-HANDLE/2,b.y-HANDLE/2,HANDLE,HANDLE);
    ctx.fillRect(b.x+b.w-HANDLE/2,b.y-HANDLE/2,HANDLE,HANDLE);
    ctx.fillRect(b.x-HANDLE/2,b.y+b.h-HANDLE/2,HANDLE,HANDLE);
    ctx.fillRect(b.x+b.w-HANDLE/2,b.y+b.h-HANDLE/2,HANDLE,HANDLE);
    ctx.restore();
  }

  // draw: color -> preset (with opacity) -> layers
  function draw(){
    if (cv.width!==state.w||cv.height!==state.h){cv.width=state.w;cv.height=state.h;}
    // color first
    ctx.fillStyle=state.bg; ctx.fillRect(0,0,cv.width,cv.height);

    // preset on top (cover) with opacity
    if (state.bgPreset && state.bgPreset.img){
      const im = state.bgPreset.img;
      const scale = Math.max(cv.width/im.naturalWidth, cv.height/im.naturalHeight);
      const w = im.naturalWidth*scale, h = im.naturalHeight*scale;
      const x = (cv.width - w)/2, y = (cv.height - h)/2;
      ctx.save();
      ctx.globalAlpha = Math.max(0, Math.min(1, state.bgPreset.alpha ?? 1));
      ctx.drawImage(im, x, y, w, h);
      ctx.restore();
    }

    // meme layers
    state.layers.forEach(l=>{
      ctx.save(); ctx.globalAlpha=l.opacity; ctx.translate(l.x,l.y); ctx.rotate(l.rot*Math.PI/180); ctx.scale(l.scale,l.scale);
      if(l.type==='image' && l.data.img){ const im=l.data.img; ctx.drawImage(im, -im.naturalWidth/2, -im.naturalHeight/2); }
      if(l.type==='text'){ const t=l.data; ctx.textAlign=t.align; ctx.textBaseline='middle'; ctx.font=`${t.size}px ${t.font}`;
        if(t.strokeWidth>0){ctx.lineWidth=t.strokeWidth; ctx.strokeStyle=t.strokeColor; ctx.strokeText(t.text,0,0);} ctx.fillStyle=t.color; ctx.fillText(t.text,0,0); }
      ctx.restore();
    });
    if(state.selected){ const b=getBounds(state.selected); drawHandles(b); }
  }

  // base loader (optionally quiet)
  function loadImg(name, quiet=false){
    return new Promise((res)=>{
      const im=new Image();
      im.onload=()=>res(im);
      im.onerror=()=>{ if(!quiet){ document.getElementById('status').textContent = 'Could not load '+name+' (check filename)'; } res(null); };
      im.src=name;
    });
  }
  function pushUniversal(img,name){
    if(!img) return;
    state.layers.push({id:name+'-'+uid(),type:'image',x:img.naturalWidth/2,y:img.naturalHeight/2,scale:1,rot:0,opacity:1,data:{src:name,img}, locked:true});
  }

  // universal stack + slots
  const PRESET = {
  slots:{
    userImage:{x:290,y:225,boxW:260,boxH:260},

    // Text under picture → now spawns at (425,365), 13pt ≈ 17px
    textBelow:{x:508.7,y:362.3,size:48,stroke:4},

    // Menu text → now spawns at (769,200), 12pt ≈ 16px
    textMenu:{x:757.2355350961997,y:207.41111111111113,size:48,stroke:3}
  }
};

  async function autoLoad(){
    warn.classList.remove('show'); warn.textContent = '';
    state.layers=[];

    // Try all filename variants for each universal asset
    const missing = [];

    const menuTry = await loadFirst(UNIVERSALS.Menu);
    if(menuTry){ pushUniversal(menuTry.img,'Menu'); } else { missing.push('Menu.png'); }

    // User image slot (editable)
    state.layers.push({id:'slot-user-image',type:'image',x:PRESET.slots.userImage.x,y:PRESET.slots.userImage.y,scale:1,rot:0,opacity:1,data:{src:'(user image)',img:null}, locked:false});

    // Text layers (editable)
    state.layers.push({id:'slot-text-below',type:'text',x:PRESET.slots.textBelow.x,y:PRESET.slots.textBelow.y,scale:1,rot:0,opacity:1,
      data:{text:'',font:'WindowsRegular, Arial, Helvetica, sans-serif',size:PRESET.slots.textBelow.size,color:'#ffffff',strokeColor:'#000000',strokeWidth:PRESET.slots.textBelow.stroke,align:'center'}, locked:false});
    state.layers.push({id:'slot-text-menu',type:'text',x:PRESET.slots.textMenu.x,y:PRESET.slots.textMenu.y,scale:1,rot:0,opacity:1,
      data:{text:'',font:'WindowsRegular, Arial, Helvetica, sans-serif',size:PRESET.slots.textMenu.size,color:'#e8e8e8',strokeColor:'#000000',strokeWidth:PRESET.slots.textMenu.stroke,align:'left'}, locked:false});

    const cursorTry = await loadFirst(UNIVERSALS.MouseCursor);
    if(cursorTry){ pushUniversal(cursorTry.img,'MouseCursor'); } else { missing.push('MouseCursor.png'); }

    const linesTry = await loadFirst(UNIVERSALS.ImageSelectLines);
    if(linesTry){ pushUniversal(linesTry.img,'ImageSelectLines'); } else { missing.push('ImageSelectLines.png'); }

    const launchTry = await loadFirst(UNIVERSALS.launchIcon);
    if(launchTry){ pushUniversal(launchTry.img,'launchIcon'); } else { missing.push('launchIcon.png'); }

    const texTry = await loadFirst(UNIVERSALS.ScreenTexture);
    if(texTry){ pushUniversal(texTry.img,'ScreenTexture'); } else { missing.push('ScreenTexture.png'); }

    if(missing.length){
      warn.textContent = 'Missing or misnamed asset(s): ' + missing.join(', ') + '. Try putting them next to index.html or in an "assets/" folder, and check case (.png/.PNG).';
      warn.classList.add('show');
    }

    draw();
  }

  // Controls
  $('#w').oninput = e=>{ state.w=+e.target.value; draw(); };
  $('#h').oninput = e=>{ state.h=+e.target.value; draw(); };
  $('#bg').oninput = e=>{ state.bg=e.target.value; draw(); };

  function openPicDialog(callback){
    const input=document.createElement('input'); input.type='file'; input.accept='image/*';
    input.onchange=ev=>{ const f=ev.target.files?.[0]; if(!f) return;
      const r=new FileReader(); r.onload=()=>{ const img=new Image(); img.onload=()=>callback(img); img.src=r.result; }; r.readAsDataURL(f);
    }; input.click();
  }
  document.getElementById('btnUploadUserPic').onclick = ()=>{
    openPicDialog((img)=>{
      const box=PRESET.slots.userImage;
      const scale=Math.min(box.boxW/img.naturalWidth, box.boxH/img.naturalHeight);
      const slot = state.layers.find(l=>l.id==='slot-user-image'); if(slot){ slot.data.img=img; slot.scale=scale; slot.x=box.x; slot.y=box.y; draw(); }
    });
  };
  document.getElementById('btnReplacePic').onclick = ()=>{
    const slot = state.layers.find(l=>l.id==='slot-user-image');
    if(!slot || !slot.data.img){ return document.getElementById('btnUploadUserPic').click(); }
    openPicDialog((img)=>{
      const box=PRESET.slots.userImage;
      const scale=slot.scale||(Math.min(box.boxW/img.naturalWidth, box.boxH/img.naturalHeight));
      slot.data.img=img; slot.scale=scale; draw();
    });
  };
  document.getElementById('btnDeletePic').onclick = ()=>{
    const slot = state.layers.find(l=>l.id==='slot-user-image'); if(slot){ slot.data.img=null; draw(); }
  };

  document.getElementById('txtBelow').oninput = e=>{ const l=state.layers.find(l=>l.id==='slot-text-below'); if(l){ l.data.text=e.target.value; draw(); }};
  document.getElementById('txtMenu').oninput  = e=>{ const l=state.layers.find(l=>l.id==='slot-text-menu');  if(l){ l.data.text=e.target.value; draw(); }};

  // hit test + drag/resize for editable layers
  function pick(x,y){
    for(let i=state.layers.length-1;i>=0;i--){
      const l=state.layers[i];
      if(l.locked) continue;
      const b=getBounds(l);
      if(x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h){
        const corners=[{x:b.x,y:b.y},{x:b.x+b.w,y:b.y},{x:b.x,y:b.y+b.h},{x:b.x+b.w,y:b.y+b.h}];
        for(const h of corners){
          if(Math.abs(x-h.x)<=HANDLE && Math.abs(y-h.y)<=HANDLE){ return {layer:l, mode:'resize', bounds:b}; }
        }
        return {layer:l, mode:'drag', bounds:b};
      }
    }
    return null;
  }
  function toCanvasCoords(evt){
    const r=cv.getBoundingClientRect();
    return { x:(evt.clientX-r.left)*(cv.width/r.width), y:(evt.clientY-r.top)*(cv.height/r.height) };
  }
  let dragging=false, start={x:0,y:0}, startLayer=null, mode=null;
  cv.addEventListener('mousedown', (e)=>{
    const p=toCanvasCoords(e);
    const hit=pick(p.x,p.y);
    if(hit){ state.selected=hit.layer; mode=hit.mode; dragging=true; start=p; startLayer={x:hit.layer.x,y:hit.layer.y,scale:hit.layer.scale,size:hit.layer.data.size||0, bounds:hit.bounds}; draw(); }
    else { state.selected=null; draw(); }
  });
  cv.addEventListener('mousemove',(e)=>{
    if(!dragging||!state.selected) return;
    const p=toCanvasCoords(e);
    const dx=p.x-start.x, dy=p.y-start.y;
    const l=state.selected;
    if(mode==='drag'){ l.x=startLayer.x+dx; l.y=startLayer.y+dy; }
    if(mode==='resize'){
      const b=startLayer.bounds; const cx=b.x+b.w/2, cy=b.y+b.h/2;
      const dist0=Math.hypot(start.x-cx,start.y-cy); const dist1=Math.hypot(p.x-cx,p.y-cy);
      const factor = dist1/Math.max(dist0,1);
      if(l.type==='image'){ l.scale = Math.max(0.1, startLayer.scale*factor); }
      if(l.type==='text'){ l.data.size = Math.max(6, Math.round(startLayer.size*factor)); }
    }
    draw();
  });
  window.addEventListener('mouseup', ()=>{ dragging=false; });

  function saveCanvas(){
    try{
      if (cv.toBlob){
        cv.toBlob(function(blob){
          const url=URL.createObjectURL(blob);
          const a=document.createElement('a'); a.href=url; a.download='meme.png';
          document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        }, 'image/png');
      } else {
        const a=document.createElement('a'); a.href=cv.toDataURL('image/png'); a.download='meme.png'; a.click();
      }
    }catch(e){
      alert('Save failed due to cross-origin image. Keep assets in this folder or upload images from your device.');
    }
  }
  document.getElementById('btn-save').onclick = saveCanvas;

  // === Background dropdown + opacity (TOP-PINNED CUSTOM OPTION) ===
  const bgSelect = document.getElementById('bgSelect');
  const bgOpacity = document.getElementById('bgOpacity');
  const bgOpacityValue = document.getElementById('bgOpacityValue');
  const bgUpload = document.getElementById('bgUpload');

  function upsertCustomOption() {
    let opt = bgSelect.querySelector('option[value="__custom__"]');
    if (!opt) {
      opt = document.createElement('option');
      opt.value = '__custom__';
      opt.textContent = 'Custom (uploaded)';
      const insertBefore = bgSelect.options[1] || null; // right after "Use color only"
      bgSelect.insertBefore(opt, insertBefore);
    } else {
      opt.textContent = 'Custom (uploaded)';
      if (bgSelect.options[1] !== opt) {
        bgSelect.removeChild(opt);
        const insertBefore = bgSelect.options[1] || null;
        bgSelect.insertBefore(opt, insertBefore);
      }
    }
    bgSelect.value = '__custom__';
  }

  bgSelect.addEventListener('change', async (e)=>{
    const src = e.target.value;

    if (src === '') {
      state.bgPreset = { src:null, img:null, alpha: parseFloat(bgOpacity.value) };
      draw();
      return;
    }

    if (src === '__upload__') {
      bgUpload.click(); // trigger file picker
      return;
    }

    if (src === '__custom__') {
      state.bgPreset.alpha = parseFloat(bgOpacity.value);
      draw();
      return;
    }

    // Preset file from disk
    const im = await loadImg(src);
    state.bgPreset = { src, img: im, alpha: parseFloat(bgOpacity.value) };
    draw();
  });

  // Handle custom background upload
  bgUpload.addEventListener('change', (ev)=>{
    const file = ev.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
      const im = new Image();
      im.onload = () => {
        state.bgPreset = { src: '(custom)', img: im, alpha: parseFloat(bgOpacity.value) };
        upsertCustomOption();  // pin & select the custom option at the top
        draw();
      };
      im.src = reader.result;
    };
    reader.readAsDataURL(file);
  });

  // Opacity slider (affects presets & custom)
  bgOpacity.addEventListener('input', ()=>{
    const a = parseFloat(bgOpacity.value);
    state.bgPreset.alpha = a;
    bgOpacityValue.textContent = Math.round(a*100) + '%';
    draw();
  });

  window.addEventListener('load', autoLoad);
  </script>
</body>
</html>
